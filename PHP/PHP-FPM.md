# PHP-FPM是如何工作的
---
> 本文默认使用 `Nginx` + `PHP-FPM` 模式
> 本文以 80端口描述， 不单独解释443端口

## 从Request到Response发生了什么
---
### (一) Http请求到达服务器
---
当你在浏览器中输入一个地址时，浏览器会将其转换成 `ip:端口` 的一次Http请求；默认情况下(不指定端口)时，会访问 `80` 端口。
如果此时服务器中，没有任何进程监听80端口，那么将不会有任何响应，也就是404。

如果此时 `Nginx` 在运行并且监听了80端口，那么Nginx此时则会开始处理这条请求；

### (二) Nginx寻找请求资源
---
在静态网页场景，Nginx会根据访问的地址来查找服务器上的资源，例如 `http://www.test.com/index/start.html` 在静态网页场景Nginx会去尝试访问 `root` 目录下 `index/start.html` 这个文件，如果找到则返回文件内容，否则则响应404。

如果此时用户请求的不再是 `.html` 的文件，而是尝试请求一个 `.php` 文件，那么会发生什么事情呢？我想许多人肯定遇到过这种情况，当请求某个 `.php` 文件时，直接返回了包含php代码在内的文件内容。

从某种角度来讲，静态资源站仅仅是将本地的一个地址，映射到网络中而已，并不做额外的处理。

### (三-1) Nginx调用其他程序处理
---
在动态网页场景，我们通常会约定当访问的文件是一个 `.php` 的文件时，交由php处理，例如 `http://www.test.com/index/start.php` 此时Nginx会根据我们的配置要求去调用 `PHP` 让其先执行 `.php` 文件然后返回处理完成的数据(CGI模式)。

### (三-2) Nginx反向代理转发请求处理
---
除了由Nginx调用其他程序处理，我们还可以通过直接将请求转发到给其他进程(服务)处理，比如目前最常见的 `PHP-FPM` 来处理请求。
此时按照默认配置，Nginx 将请求转发到 9000 端口(Fpm默认端口，也可能使用sock)交给 `PHP-FPM` 处理。

### (四) PHP-FPM如何处理请求
---
php-fpm 是一个多进程模型的服务，当启动 php-fpm 时， php-fpm将会读取配置文件，然后预创建(fork)出少量子进程等待请求(动态) 或者一次性创建足够的子进程等待请求(静态)。

当请求到达 fpm 时，主进程立刻分配一个空闲的子进程来处理请求(执行.php文件)，当子进程执行完成后，将响应返回给Nginx然后退出进程(动态并且超过常驻进程数)或是仅执行Zend的垃圾回收然后继续等待请求。

## Nginx如何同PHP-FPM交互
---
Nginx 和 PHP-FPM 使用 SAPI来交互
![SAPI](/static/image/SAPI.jpg)
